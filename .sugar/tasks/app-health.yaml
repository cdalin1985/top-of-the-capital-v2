tasks:
  # 1) Inspect repo & produce a machine-readable snapshot
  - id: assess_state
    description: Inventory apps, env, docker, tests, and produce state.json
    run: |
      tmp=".sugar/artifacts"
      inv="$tmp/state.json"
      mkdir -p "$tmp"
      echo '{}' | jq '.' > "$inv"

      # Node apps
      node_list=$(fd -H --type f package.json 2>/dev/null | sort)
      jq --argjson arr "$(printf '%s\n' "$node_list" | jq -R . | jq -s .)" \
         '.node.package_jsons = $arr' "$inv" > "$inv.tmp" && mv "$inv.tmp" "$inv"

      # Python apps
      py_list=$(fd -H --type f "(pyproject.toml|requirements.txt|manage.py)" 2>/dev/null | sort)
      jq --argjson arr "$(printf '%s\n' "$py_list" | jq -R . | jq -s .)" \
         '.python.project_files = $arr' "$inv" > "$inv.tmp" && mv "$inv.tmp" "$inv"

      # Go/Rust
      go_list=$(fd -H --type f go.mod 2>/dev/null | sort)
      rs_list=$(fd -H --type f Cargo.toml 2>/dev/null | sort)
      jq --argjson go "$(printf '%s\n' "$go_list" | jq -R . | jq -s .)" \
         --argjson rs "$(printf '%s\n' "$rs_list" | jq -R . | jq -s .)" \
         '.go.modules = $go | .rust.cargo = $rs' "$inv" > "$inv.tmp" && mv "$inv.tmp" "$inv"

      # Docker / Compose / K8s
      dk_list=$(fd -H --type f "(Dockerfile|docker-compose.yml|compose.yaml|Chart.yaml|deployment.yaml|values.yaml)" 2>/dev/null | sort)
      jq --argjson arr "$(printf '%s\n' "$dk_list" | jq -R . | jq -s .)" \
         '.containers.files = $arr' "$inv" > "$inv.tmp" && mv "$inv.tmp" "$inv"

      # Tests
      ts_list=$(fd -H --type f "(.*\.(test|spec)\.(js|ts|tsx|py|go|rs)|pytest\.ini|jest\.config.*|vitest\.config.*|go\.sum)" 2>/dev/null | sort)
      jq --argjson arr "$(printf '%s\n' "$ts_list" | jq -R . | jq -s .)" \
         '.tests.files = $arr' "$inv" > "$inv.tmp" && mv "$inv.tmp" "$inv"

      # Env files
      env_list=$(fd -H --type f "(.env|.env.*|.env.example)" 2>/dev/null | sort)
      jq --argjson arr "$(printf '%s\n' "$env_list" | jq -R . | jq -s .)" \
         '.env.files = $arr' "$inv" > "$inv.tmp" && mv "$inv.tmp" "$inv"

      echo "Wrote $inv"

  # 2) From that state, synthesize a new queue with concrete TODO tasks
  - id: plan_tasks
    description: Generate actionable tasks based on state.json
    needs: [assess_state]
    run: |
      inv=".sugar/artifacts/state.json"
      outdir=".sugar/generated"; mkdir -p "$outdir"
      plan="$outdir/tasks.generated.yaml"
      : > "$plan"
      echo "tasks:" >> "$plan"

      # If no Dockerfiles, propose dockerization tasks
      if [ "$(jq '.containers.files | length' "$inv")" -eq 0 ]; then
        cat >> "$plan" <<'EOF'
  - id: dockerize_node_apps
    description: Create multi-stage Dockerfiles and a compose file for Node apps
    run: |
      for p in $(jq -r '.node.package_jsons[]?' .sugar/artifacts/state.json | xargs -r -n1 dirname | sort -u); do
        cat > "$p/Dockerfile" <<'DOK'
# syntax=docker/dockerfile:1
FROM node:20 AS deps
WORKDIR /app
COPY package*.json ./
RUN npm ci || npm install
COPY . .
RUN npm run build || true
FROM node:20-slim
WORKDIR /app
ENV NODE_ENV=production
COPY --from=deps /app ./
EXPOSE 3000
CMD ["npm","start"]
DOK
      done
      cat > docker-compose.yml <<'COMPOSE'
services:
  web:
    build: .
    ports: ["3000:3000"]
    env_file: .env
COMPOSE
EOF
      fi

      # If no .env.example, create from code hints
      if [ "$(jq '.env.files | length' "$inv")" -eq 0 ]; then
        cat >> "$plan" <<'EOF'
  - id: create_env_example
    description: Generate .env.example from code references
    run: |
      grep -RhoE 'process\.env\.[A-Z0-9_]+' . \
        | sed -E 's/.*process\.env\.//' \
        | tr -d ' ' | sort -u | awk '{print $0"="}' > .env.example
      grep -RhoE 'os\.getenv\(["'"'"']([A-Z0-9_]+)["'"'"']\)' . \
        | sed -E 's/.*getenv\(["'"'"']([A-Z0-9_]+)["'"'"']\).*/\1/' \
        | sort -u | awk '{print $0"="}' >> .env.example
      sort -u .env.example -o .env.example
      echo "Wrote .env.example"
EOF
      fi

      # Always add a healthcheck + CI baseline
      cat >> "$plan" <<'EOF'
  - id: scaffold_healthcheck_and_ci
    description: Add /healthz endpoint and a minimal GitHub CI workflow
    run: |
      echo -e "## Healthcheck\n\nExpose GET /healthz returning 200 OK.\n" >> README.md
      mkdir -p .github/workflows
      cat > .github/workflows/ci.yml <<'YML'
name: CI
on: [push, pull_request]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: '20'
      - run: |
          if [ -f package.json ]; then
            npm ci || npm install
            npm test --silent || true
          else
            echo "No root JS project; per-app CI later."
          fi
YML
EOF

      echo "Wrote $plan"

  # 3) Execute the newly generated tasks
  - id: execute_generated_plan
    description: Run the tasks.generated.yaml plan
    needs: [plan_tasks]
    run: |
      echo "Executing .sugar/generated/tasks.generated.yaml"
      sugar run --file .sugar/generated/tasks.generated.yaml || true
